local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

local mapFrame = script.Parent.Frame.Minimap.MapFrame
local dotsContainer = mapFrame:WaitForChild("DotsContainer")

local lastUpdate = 0
local UPDATE_INTERVAL = 0.05 -- 0.05ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸ (1ì´ˆì— 20ë²ˆ)

-- ==========================================
-- ğŸ—ºï¸ ë§µ ì„¤ì • (144x144, 6x6 íƒ€ì¼ë§µ ê¸°ì¤€)
-- ==========================================
local MAP_SIZE = Vector2.new(200, 200)
local MAP_CENTER = Vector3.new(6, 2.5, -127)
local TAG_NAME = "MinimapUnit" -- ê°ì§€í•  íƒœê·¸ ì´ë¦„
-- ==========================================

-- í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ì ë“¤ì„ ê´€ë¦¬í•˜ëŠ” í…Œì´ë¸” (ìœ ë‹› íŒŒíŠ¸ -> ì  GUI)
local activeBlips = {}

-- 1. ì›”ë“œ ì¢Œí‘œ -> ë¯¸ë‹ˆë§µ ì¢Œí‘œ ë³€í™˜
local function worldToMap(worldPos)
    local currentFrameSize = mapFrame.AbsoluteSize

	local relativePos = worldPos - MAP_CENTER
	local scaleX = relativePos.X / currentFrameSize.X
	local scaleY = relativePos.Z / currentFrameSize.Y 
	return UDim2.new(0.5 + scaleX, 0, 0.5 + scaleY, 0)
end

-- 2. ì (Blip) ìƒì„± í•¨ìˆ˜
local function createBlip(targetPart)
	if activeBlips[targetPart] then 
        return 
    end -- ì´ë¯¸ ìˆìœ¼ë©´ íŒ¨ìŠ¤

	local blip = Instance.new("Frame")
	blip.Name = "UnitDot"
	blip.Size = UDim2.new(0, 4, 0, 4) -- ì  í¬ê¸° (4í”½ì…€)
	blip.BorderSizePixel = 0
    blip.ZIndex = 10 
	
	-- ìƒ‰ìƒ ê²°ì • ë¡œì§
	-- 1ìˆœìœ„: íŒŒíŠ¸ì— 'DotColor'ë¼ëŠ” ì†ì„±(Attribute)ì´ ìˆìœ¼ë©´ ê·¸ ìƒ‰ ì‚¬ìš©
	-- 2ìˆœìœ„: ì—†ìœ¼ë©´ ê¸°ë³¸ ë¹¨ê°„ìƒ‰
	local colorAttr = targetPart:GetAttribute("DotColor")
	if colorAttr then
		blip.BackgroundColor3 = colorAttr
	else
		blip.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- ê¸°ë³¸ê°’: ë¹¨ê°•
	end

	-- ë‘¥ê¸€ê²Œ ë§Œë“¤ê¸°
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = blip
	
	blip.AnchorPoint = Vector2.new(0.5, 0.5)
	blip.Parent = dotsContainer
	
	-- í…Œì´ë¸”ì— ë“±ë¡
	activeBlips[targetPart] = blip
end

-- 3. ì  ì œê±° í•¨ìˆ˜
local function removeBlip(targetPart)
	if activeBlips[targetPart] then
		activeBlips[targetPart]:Destroy()
		activeBlips[targetPart] = nil
	end
end

-- ==========================================
-- ğŸ“¡ ì´ë²¤íŠ¸ ì—°ê²° (íƒœê·¸ ê°ì§€ ì‹œìŠ¤í…œ)
-- ==========================================

-- A. ê²Œì„ ì‹œì‘ ì‹œ ì´ë¯¸ ìˆëŠ” íƒœê·¸ëœ íŒŒíŠ¸ë“¤ ì²˜ë¦¬
for _, part in pairs(CollectionService:GetTagged(TAG_NAME)) do
	createBlip(part)
end

-- B. ìƒˆë¡­ê²Œ íƒœê·¸ëœ íŒŒíŠ¸ê°€ ë“¤ì–´ì˜¤ë©´ ê°ì§€ (ìŠ¤í° ë“±)
CollectionService:GetInstanceAddedSignal(TAG_NAME):Connect(createBlip)

-- C. íƒœê·¸ëœ íŒŒíŠ¸ê°€ ì‚¬ë¼ì§€ê±°ë‚˜ íƒœê·¸ê°€ ë¹ ì§€ë©´ ê°ì§€ (ì‚¬ë§ ë“±)
CollectionService:GetInstanceRemovedSignal(TAG_NAME):Connect(removeBlip)

-- ==========================================
-- ğŸ”„ ë§¤ í”„ë ˆì„ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
-- ==========================================
RunService.RenderStepped:Connect(function(dt)
    lastUpdate = lastUpdate + dt
    
    if lastUpdate < UPDATE_INTERVAL then 
        return 
    end 
    
    lastUpdate = 0

    local currentFrameSize = mapFrame.AbsoluteSize

	for part, blip in pairs(activeBlips) do
		if part.Parent then -- íŒŒíŠ¸ê°€ ì„¸ìƒì— ì¡´ì¬í•˜ë©´
			blip.Position = worldToMap(part.Position)
		else
			-- íŒŒíŠ¸ê°€ ì‚¬ë¼ì¡ŒëŠ”ë° ì´ë²¤íŠ¸ê°€ ëŠ¦ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ì—¬ê¸°ì„œë„ ì‚­ì œ
			removeBlip(part)
		end
	end
	
	
end)